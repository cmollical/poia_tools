{"ast":null,"code":"// API service for communicating with FastAPI backend\n\nconst API_BASE_URL = 'http://localhost:8000/api/v1';\nclass ApiService {\n  /**\n   * Process transcript using backend AI service\n   * @param {Object} options - Options object containing transcript and other parameters\n   * @param {string} options.transcript - Raw transcript text\n   * @param {string} [options.mode] - Processing mode ('jira' or 'confluence')\n   * @param {boolean} [options.multipleIssues] - Whether to create multiple issues\n   * @param {boolean} [options.multiplePages] - Whether to create multiple pages\n   * @param {string} [options.projectKey] - Jira project key\n   * @param {string} [options.spaceKey] - Confluence space key\n   * @returns {Promise<Object>} Processed transcript data\n   */\n  async processTranscript(options) {\n    try {\n      // Extract the transcript from options\n      const {\n        transcript\n      } = options;\n\n      // Create project context from the additional parameters\n      const projectContext = JSON.stringify({\n        mode: options.mode,\n        multipleIssues: options.multipleIssues,\n        multiplePages: options.multiplePages,\n        projectKey: options.projectKey,\n        spaceKey: options.spaceKey\n      });\n      console.log('üîç Sending transcript request with context:', projectContext);\n      const response = await fetch(`${API_BASE_URL}/transcript/process`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          transcript,\n          user_id: null,\n          project_context: projectContext\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error processing transcript:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clean transcript text only (without full AI processing)\n   * @param {string} transcript - Raw transcript text\n   * @returns {Promise<Object>} Cleaned transcript data\n   */\n  async cleanTranscript(transcript) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/transcript/clean`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          transcript\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error cleaning transcript:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check backend health status\n   * @returns {Promise<Object>} Health status\n   */\n  async checkHealth() {\n    try {\n      const response = await fetch('http://localhost:8000/health');\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking backend health:', error);\n      return {\n        status: 'unhealthy',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Check transcript service health\n   * @returns {Promise<Object>} Transcript service health status\n   */\n  async checkTranscriptHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/transcript/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking transcript service health:', error);\n      return {\n        status: 'unhealthy',\n        service: 'transcript_processing',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Download Excel file with all exported stories\n   * @returns {Promise<void>} Triggers file download\n   */\n  async downloadExcelFile() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/excel/download`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      // Create blob from response\n      const blob = await response.blob();\n\n      // Create download link\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = 'project_stories.xlsx';\n\n      // Trigger download\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      // Clean up\n      window.URL.revokeObjectURL(url);\n    } catch (error) {\n      console.error('Error downloading Excel file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get Excel export summary\n   * @returns {Promise<Object>} Excel export summary data\n   */\n  async getExcelSummary() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/excel/summary`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting Excel summary:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get Jira features from a project\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {number} maxResults - Maximum number of results to return\n   * @returns {Promise<Array>} Array of Jira features\n   */\n  async getJiraFeatures(projectKey = 'ROIA', maxResults = 50) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/features?max_results=${maxResults}&project_key=${projectKey}`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error fetching Jira features for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue from intent data\n   * @param {Object} intentData - Intent data with classified_intent\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {string} epicKey - Optional epic key to link the issue to\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssueFromIntent(intentData, projectKey = 'ROIA', epicKey = null) {\n    try {\n      // Create a ProcessTranscriptResponse-like object that the backend expects\n      const processedData = {\n        success: true,\n        classified_intent: intentData.classified_intent || intentData.content,\n        epic_match: intentData.epic_match || null,\n        cleaned_transcript: '',\n        processing_time_ms: 0\n      };\n      console.log('üîç Creating Jira issue with epic key:', epicKey);\n      return await this.createJiraIssue(processedData, projectKey, epicKey);\n    } catch (error) {\n      console.error(`Error creating Jira issue from intent for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue from processed transcript data\n   * @param {Object} processedData - Processed transcript data\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {string} epicKey - Optional epic key to link the issue to\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssue(processedData, projectKey = 'ROIA', epicKey = null) {\n    try {\n      let url = `${API_BASE_URL}/jira/create-from-intent?project_key=${projectKey}`;\n      if (epicKey) {\n        url += `&epic_key=${epicKey}`;\n      }\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(processedData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error creating Jira issue for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Confluence page\n   * @param {Object} pageData - Page data including title, body, etc.\n   * @param {string} spaceKey - Confluence space key\n   * @param {string} parentPageId - Optional parent page ID\n   * @returns {Promise<Object>} Created Confluence page data\n   */\n  async createConfluencePage(pageData, spaceKey, parentPageId = null) {\n    try {\n      console.log('üîç Creating Confluence page:', {\n        pageData,\n        spaceKey,\n        parentPageId\n      });\n\n      // Format content as HTML for Confluence storage format\n      const bodyContent = pageData.body || pageData.content;\n      const formattedContent = this._formatConfluenceContent(bodyContent);\n      let url = `${API_BASE_URL}/confluence/create-page?space_key=${spaceKey}`;\n      if (parentPageId) {\n        url += `&parent_id=${parentPageId}`;\n      }\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          title: pageData.title,\n          content: formattedContent\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('‚úÖ Confluence page created:', result);\n      return result;\n    } catch (error) {\n      console.error(`Error creating Confluence page in space ${spaceKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Format content for Confluence storage format with improved structure\n   * @param {string} content - Raw content to format\n   * @returns {string} HTML formatted for Confluence storage\n   * @private\n   */\n  _formatConfluenceContent(content) {\n    if (!content) return '<p>No content provided</p>';\n\n    // If content is already HTML, return it\n    if (content.startsWith('<') && content.includes('</')) {\n      return content;\n    }\n\n    // Create a more structured document\n    let html = '<div class=\"confluence-content\">';\n\n    // Add a table of contents macro if content is substantial\n    if (content.length > 500) {\n      html += '<ac:structured-macro ac:name=\"toc\">' + '<ac:parameter ac:name=\"printable\">true</ac:parameter>' + '<ac:parameter ac:name=\"style\">disc</ac:parameter>' + '<ac:parameter ac:name=\"maxLevel\">3</ac:parameter>' + '<ac:parameter ac:name=\"minLevel\">1</ac:parameter>' + '</ac:structured-macro>';\n    }\n\n    // Process content by paragraphs\n    const paragraphs = content.split('\\n\\n');\n    let inList = false;\n    let listHtml = '';\n    paragraphs.forEach(paragraph => {\n      const trimmed = paragraph.trim();\n      if (!trimmed) return;\n\n      // Check for different content types\n      if (trimmed.startsWith('# ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n\n        // H1 heading\n        const heading = trimmed.substring(2);\n        html += `<h1>${heading}</h1>`;\n      } else if (trimmed.startsWith('## ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n\n        // H2 heading\n        const heading = trimmed.substring(3);\n        html += `<h2>${heading}</h2>`;\n      } else if (trimmed.startsWith('* ')) {\n        // List item\n        if (!inList) {\n          inList = true;\n          listHtml = '<ul class=\"confluence-list\">';\n        }\n        const item = trimmed.substring(2);\n        listHtml += `<li>${item}</li>`;\n      } else if (trimmed.startsWith('> ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n\n        // Blockquote\n        const quote = trimmed.substring(2);\n        html += `<blockquote>${quote}</blockquote>`;\n      } else {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n\n        // Regular paragraph\n        html += `<p>${trimmed.replace(/\\n/g, '<br/>')}</p>`;\n      }\n    });\n\n    // Close any open list at the end\n    if (inList) {\n      html += listHtml + '</ul>';\n    }\n\n    // Close the main content div\n    html += '</div>';\n    return html;\n  }\n\n  /**\n   * Create a new epic in Jira\n   * @param {string} epicName - Name of the epic\n   * @param {string} epicSummary - Summary of the epic\n   * @param {string} epicDescription - Description of the epic\n   * @param {string} projectKey - Jira project key\n   * @returns {Promise<Object>} Created epic data\n   */\n  async createJiraEpic(epicName, epicSummary, epicDescription = '', projectKey = 'ROIA') {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/create-epic?project_key=${projectKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          epic_name: epicName,\n          epic_summary: epicSummary,\n          epic_description: epicDescription\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error creating Jira epic:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check Jira connection health\n   * @returns {Promise<Object>} Jira health status\n   */\n  async checkJiraHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking Jira health:', error);\n      return {\n        status: 'unhealthy',\n        service: 'jira',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Get all epics from a project\n   * @param {string} projectKey - Jira project key\n   * @param {number} maxResults - Maximum number of results to return\n   * @returns {Promise<Array>} Array of Jira epics\n   */\n  async getJiraEpics(projectKey = 'ROIA', maxResults = 500) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/epics?project_key=${projectKey}&max_results=${maxResults}`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error fetching Jira epics for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find epics that match the classified intent and user context\n   * @param {Object} classifiedIntent - The classified intent\n   * @param {Object} userInfo - Optional user information\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {number} maxResults - Maximum number of matching epics to return\n   * @returns {Promise<Array>} Array of matching epics with match scores\n   */\n  async matchJiraEpics(classifiedIntent, userInfo = null, projectKey = 'ROIA', maxResults = 3) {\n    try {\n      if (!classifiedIntent) {\n        throw new Error(\"Classified intent is required\");\n      }\n\n      // Create a properly sanitized version of the intent to match the backend model\n      // This ensures we don't send extra or invalid fields that would cause validation errors\n      // Based on the backend ClassifiedIntent model, we need exact enum values\n      const sanitizedIntent = {\n        type: String(classifiedIntent.type || 'story').toLowerCase(),\n        summary: String(classifiedIntent.summary || ''),\n        description: String(classifiedIntent.description || 'No description provided'),\n        acceptance_criteria: Array.isArray(classifiedIntent.acceptance_criteria) ? classifiedIntent.acceptance_criteria.map(ac => String(ac)) : [],\n        priority: String(classifiedIntent.priority || 'medium').toLowerCase(),\n        epic_keywords: Array.isArray(classifiedIntent.epic_keywords) ? classifiedIntent.epic_keywords.map(kw => String(kw)) : [],\n        confidence: Math.max(0.0, Math.min(1.0, Number(classifiedIntent.confidence || 0.8)))\n      };\n\n      // Validate enum values to match backend expectations\n      const validTypes = ['story', 'bug', 'task', 'epic', 'comment'];\n      const validPriorities = ['low', 'medium', 'high', 'critical'];\n      if (!validTypes.includes(sanitizedIntent.type)) {\n        console.warn(`Invalid type '${sanitizedIntent.type}', defaulting to 'story'`);\n        sanitizedIntent.type = 'story';\n      }\n      if (!validPriorities.includes(sanitizedIntent.priority)) {\n        console.warn(`Invalid priority '${sanitizedIntent.priority}', defaulting to 'medium'`);\n        sanitizedIntent.priority = 'medium';\n      }\n      const requestBody = {\n        classified_intent: sanitizedIntent,\n        max_results: maxResults\n      };\n\n      // Add user info if provided\n      if (userInfo) {\n        requestBody.user_info = {\n          username: String(userInfo.username || 'current_user'),\n          display_name: userInfo.display_name ? String(userInfo.display_name) : null,\n          email: userInfo.email ? String(userInfo.email) : null,\n          department: userInfo.department ? String(userInfo.department) : null\n        };\n      }\n      console.log('Sanitized request body for match-epics:', JSON.stringify(requestBody, null, 2));\n\n      // Use query parameter for project_key to match the updated backend API\n      const url = new URL(`${API_BASE_URL}/jira/match-epics`);\n      url.searchParams.append('project_key', projectKey);\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n          const errorData = await response.json();\n          throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        } else {\n          const errorText = await response.text();\n          throw new Error(errorText || `HTTP error! status: ${response.status}`);\n        }\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error matching Jira epics for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue and link it to the specified epic\n   * @param {Object} processedData - Processed transcript data\n   * @param {string} epicKey - The epic key to link the issue to\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssueWithEpic(processedData, epicKey, projectKey = 'ROIA') {\n    try {\n      if (!processedData || !epicKey) {\n        throw new Error(\"Processed data and epic key are required\");\n      }\n\n      // Validate project key against allowed values\n      const allowedProjectKeys = ['ROIA', 'PROPS'];\n      if (!allowedProjectKeys.includes(projectKey)) {\n        throw new Error(`Invalid project key. Allowed values: ${allowedProjectKeys.join(', ')}`);\n      }\n      const response = await fetch(`${API_BASE_URL}/jira/create-with-epic?project_key=${projectKey}&epic_key=${epicKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(processedData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(`Error creating Jira issue with epic link in project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current user info from session or browser\n   * @returns {Object} User information that can be used for context-aware matching\n   */\n  getCurrentUserInfo() {\n    // In a real application, this would come from authentication\n    // For now, we'll use dummy data or try to extract from browser\n    const userInfo = {\n      username: sessionStorage.getItem('username') || 'current_user',\n      display_name: sessionStorage.getItem('display_name') || 'Current User',\n      email: sessionStorage.getItem('email') || null,\n      department: sessionStorage.getItem('department') || null\n    };\n    return userInfo;\n  }\n\n  // Confluence API Methods\n\n  /**\n   * Check the health of the Confluence connection\n   * @returns {Promise<Object>} Health status information\n   */\n  async checkConfluenceHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/health`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking Confluence health:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get pages from a Confluence space\n   * @param {string} spaceKey - The space key to retrieve pages from\n   * @param {number} maxResults - Maximum number of pages to return\n   * @returns {Promise<Array>} Array of Confluence pages\n   */\n  async getConfluencePages(spaceKey = 'ROIA', maxResults = 500) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/pages?space_key=${spaceKey}&max_results=${maxResults}`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching Confluence pages:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find Confluence pages that match the classified intent\n   * @param {Object} classifiedIntent - The classified intent\n   * @param {Object} userInfo - Optional user information\n   * @param {string} spaceKey - Confluence space to search in\n   * @param {number} maxResults - Maximum number of matching pages to return\n   * @returns {Promise<Array>} Array of matching pages with match scores\n   */\n  async matchConfluencePages(classifiedIntent, userInfo = null, spaceKey = 'ROIA', maxResults = 3) {\n    try {\n      // Sanitize and format the classified intent similar to Jira integration\n      const sanitizedIntent = {\n        type: String(classifiedIntent.type || 'story').toLowerCase(),\n        summary: String(classifiedIntent.summary || ''),\n        description: String(classifiedIntent.description || 'No description provided'),\n        acceptance_criteria: Array.isArray(classifiedIntent.acceptance_criteria) ? classifiedIntent.acceptance_criteria : [],\n        priority: String(classifiedIntent.priority || 'medium').toLowerCase(),\n        epic_keywords: Array.isArray(classifiedIntent.epic_keywords) ? classifiedIntent.epic_keywords : [],\n        confidence: Number(classifiedIntent.confidence || 0.8)\n      };\n      const requestBody = {\n        classified_intent: sanitizedIntent,\n        space_key: spaceKey,\n        max_results: maxResults\n      };\n\n      // Add user info if provided\n      if (userInfo) {\n        requestBody.user_info = {\n          username: String(userInfo.username || 'current_user'),\n          display_name: userInfo.display_name ? String(userInfo.display_name) : null,\n          email: userInfo.email ? String(userInfo.email) : null,\n          department: userInfo.department ? String(userInfo.department) : null\n        };\n      }\n      const response = await fetch(`${API_BASE_URL}/confluence/match-pages`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n          const errorData = await response.json();\n          throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        } else {\n          const errorText = await response.text();\n          throw new Error(errorText || `HTTP error! status: ${response.status}`);\n        }\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error matching Confluence pages:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update a Confluence page with new content\n   * @param {string} pageId - The ID of the page to update\n   * @param {string} content - The content to add/update\n   * @param {string} comment - Version comment\n   * @param {boolean} append - Whether to append content or replace it\n   * @returns {Promise<Object>} Update response with page URL\n   */\n  async updateConfluencePage(pageId, content, comment = 'Updated via AI Project Management Suite', append = true) {\n    try {\n      const requestBody = {\n        page_id: pageId,\n        content: content,\n        comment: comment,\n        append: append\n      };\n      const response = await fetch(`${API_BASE_URL}/confluence/update-page`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error updating Confluence page:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get a specific Confluence page by ID\n   * @param {string} pageId - The ID of the page to retrieve\n   * @returns {Promise<Object>} Page data\n   */\n  async getConfluencePage(pageId) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/page/${pageId}`);\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching Confluence page:', error);\n      throw error;\n    }\n  }\n}\nconst apiService = new ApiService();\nexport default apiService;","map":{"version":3,"names":["API_BASE_URL","ApiService","processTranscript","options","transcript","projectContext","JSON","stringify","mode","multipleIssues","multiplePages","projectKey","spaceKey","console","log","response","fetch","method","headers","body","user_id","project_context","ok","errorData","json","Error","detail","status","error","cleanTranscript","checkHealth","message","checkTranscriptHealth","service","downloadExcelFile","blob","url","window","URL","createObjectURL","link","document","createElement","href","download","appendChild","click","removeChild","revokeObjectURL","getExcelSummary","getJiraFeatures","maxResults","createJiraIssueFromIntent","intentData","epicKey","processedData","success","classified_intent","content","epic_match","cleaned_transcript","processing_time_ms","createJiraIssue","createConfluencePage","pageData","parentPageId","bodyContent","formattedContent","_formatConfluenceContent","title","result","startsWith","includes","html","length","paragraphs","split","inList","listHtml","forEach","paragraph","trimmed","trim","heading","substring","item","quote","replace","createJiraEpic","epicName","epicSummary","epicDescription","epic_name","epic_summary","epic_description","checkJiraHealth","getJiraEpics","matchJiraEpics","classifiedIntent","userInfo","sanitizedIntent","type","String","toLowerCase","summary","description","acceptance_criteria","Array","isArray","map","ac","priority","epic_keywords","kw","confidence","Math","max","min","Number","validTypes","validPriorities","warn","requestBody","max_results","user_info","username","display_name","email","department","searchParams","append","contentType","get","indexOf","errorText","text","createJiraIssueWithEpic","allowedProjectKeys","join","getCurrentUserInfo","sessionStorage","getItem","checkConfluenceHealth","getConfluencePages","matchConfluencePages","space_key","updateConfluencePage","pageId","comment","page_id","getConfluencePage","apiService"],"sources":["C:/poia_tools/roia-suite/frontend/src/services/api.js"],"sourcesContent":["// API service for communicating with FastAPI backend\n\nconst API_BASE_URL = 'http://localhost:8000/api/v1';\n\nclass ApiService {\n  /**\n   * Process transcript using backend AI service\n   * @param {Object} options - Options object containing transcript and other parameters\n   * @param {string} options.transcript - Raw transcript text\n   * @param {string} [options.mode] - Processing mode ('jira' or 'confluence')\n   * @param {boolean} [options.multipleIssues] - Whether to create multiple issues\n   * @param {boolean} [options.multiplePages] - Whether to create multiple pages\n   * @param {string} [options.projectKey] - Jira project key\n   * @param {string} [options.spaceKey] - Confluence space key\n   * @returns {Promise<Object>} Processed transcript data\n   */\n  async processTranscript(options) {\n    try {\n      // Extract the transcript from options\n      const { transcript } = options;\n      \n      // Create project context from the additional parameters\n      const projectContext = JSON.stringify({\n        mode: options.mode,\n        multipleIssues: options.multipleIssues,\n        multiplePages: options.multiplePages,\n        projectKey: options.projectKey,\n        spaceKey: options.spaceKey\n      });\n      \n      console.log('üîç Sending transcript request with context:', projectContext);\n      \n      const response = await fetch(`${API_BASE_URL}/transcript/process`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          transcript,\n          user_id: null,\n          project_context: projectContext\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error processing transcript:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clean transcript text only (without full AI processing)\n   * @param {string} transcript - Raw transcript text\n   * @returns {Promise<Object>} Cleaned transcript data\n   */\n  async cleanTranscript(transcript) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/transcript/clean`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          transcript\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error cleaning transcript:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check backend health status\n   * @returns {Promise<Object>} Health status\n   */\n  async checkHealth() {\n    try {\n      const response = await fetch('http://localhost:8000/health');\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking backend health:', error);\n      return {\n        status: 'unhealthy',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Check transcript service health\n   * @returns {Promise<Object>} Transcript service health status\n   */\n  async checkTranscriptHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/transcript/health`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking transcript service health:', error);\n      return {\n        status: 'unhealthy',\n        service: 'transcript_processing',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Download Excel file with all exported stories\n   * @returns {Promise<void>} Triggers file download\n   */\n  async downloadExcelFile() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/excel/download`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      // Create blob from response\n      const blob = await response.blob();\n      \n      // Create download link\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = 'project_stories.xlsx';\n      \n      // Trigger download\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      // Clean up\n      window.URL.revokeObjectURL(url);\n      \n    } catch (error) {\n      console.error('Error downloading Excel file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get Excel export summary\n   * @returns {Promise<Object>} Excel export summary data\n   */\n  async getExcelSummary() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/excel/summary`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting Excel summary:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get Jira features from a project\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {number} maxResults - Maximum number of results to return\n   * @returns {Promise<Array>} Array of Jira features\n   */\n  async getJiraFeatures(projectKey = 'ROIA', maxResults = 50) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/features?max_results=${maxResults}&project_key=${projectKey}`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error(`Error fetching Jira features for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue from intent data\n   * @param {Object} intentData - Intent data with classified_intent\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {string} epicKey - Optional epic key to link the issue to\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssueFromIntent(intentData, projectKey = 'ROIA', epicKey = null) {\n    try {\n      // Create a ProcessTranscriptResponse-like object that the backend expects\n      const processedData = {\n        success: true,\n        classified_intent: intentData.classified_intent || intentData.content,\n        epic_match: intentData.epic_match || null,\n        cleaned_transcript: '',\n        processing_time_ms: 0\n      };\n      \n      console.log('üîç Creating Jira issue with epic key:', epicKey);\n      return await this.createJiraIssue(processedData, projectKey, epicKey);\n    } catch (error) {\n      console.error(`Error creating Jira issue from intent for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue from processed transcript data\n   * @param {Object} processedData - Processed transcript data\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {string} epicKey - Optional epic key to link the issue to\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssue(processedData, projectKey = 'ROIA', epicKey = null) {\n    try {\n      let url = `${API_BASE_URL}/jira/create-from-intent?project_key=${projectKey}`;\n      if (epicKey) {\n        url += `&epic_key=${epicKey}`;\n      }\n      \n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(processedData)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`Error creating Jira issue for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Confluence page\n   * @param {Object} pageData - Page data including title, body, etc.\n   * @param {string} spaceKey - Confluence space key\n   * @param {string} parentPageId - Optional parent page ID\n   * @returns {Promise<Object>} Created Confluence page data\n   */\n  async createConfluencePage(pageData, spaceKey, parentPageId = null) {\n    try {\n      console.log('üîç Creating Confluence page:', { pageData, spaceKey, parentPageId });\n      \n      // Format content as HTML for Confluence storage format\n      const bodyContent = pageData.body || pageData.content;\n      const formattedContent = this._formatConfluenceContent(bodyContent);\n      \n      let url = `${API_BASE_URL}/confluence/create-page?space_key=${spaceKey}`;\n      if (parentPageId) {\n        url += `&parent_id=${parentPageId}`;\n      }\n      \n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          title: pageData.title,\n          content: formattedContent\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n      console.log('‚úÖ Confluence page created:', result);\n      return result;\n    } catch (error) {\n      console.error(`Error creating Confluence page in space ${spaceKey}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Format content for Confluence storage format with improved structure\n   * @param {string} content - Raw content to format\n   * @returns {string} HTML formatted for Confluence storage\n   * @private\n   */\n  _formatConfluenceContent(content) {\n    if (!content) return '<p>No content provided</p>';\n    \n    // If content is already HTML, return it\n    if (content.startsWith('<') && content.includes('</')) {\n      return content;\n    }\n    \n    // Create a more structured document\n    let html = '<div class=\"confluence-content\">';\n    \n    // Add a table of contents macro if content is substantial\n    if (content.length > 500) {\n      html += '<ac:structured-macro ac:name=\"toc\">' +\n             '<ac:parameter ac:name=\"printable\">true</ac:parameter>' +\n             '<ac:parameter ac:name=\"style\">disc</ac:parameter>' +\n             '<ac:parameter ac:name=\"maxLevel\">3</ac:parameter>' +\n             '<ac:parameter ac:name=\"minLevel\">1</ac:parameter>' +\n             '</ac:structured-macro>';\n    }\n    \n    // Process content by paragraphs\n    const paragraphs = content.split('\\n\\n');\n    let inList = false;\n    let listHtml = '';\n    \n    paragraphs.forEach(paragraph => {\n      const trimmed = paragraph.trim();\n      if (!trimmed) return;\n      \n      // Check for different content types\n      if (trimmed.startsWith('# ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n        \n        // H1 heading\n        const heading = trimmed.substring(2);\n        html += `<h1>${heading}</h1>`;\n      } else if (trimmed.startsWith('## ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n        \n        // H2 heading\n        const heading = trimmed.substring(3);\n        html += `<h2>${heading}</h2>`;\n      } else if (trimmed.startsWith('* ')) {\n        // List item\n        if (!inList) {\n          inList = true;\n          listHtml = '<ul class=\"confluence-list\">';\n        }\n        const item = trimmed.substring(2);\n        listHtml += `<li>${item}</li>`;\n      } else if (trimmed.startsWith('> ')) {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n        \n        // Blockquote\n        const quote = trimmed.substring(2);\n        html += `<blockquote>${quote}</blockquote>`;\n      } else {\n        // Close any open list\n        if (inList) {\n          html += listHtml + '</ul>';\n          inList = false;\n          listHtml = '';\n        }\n        \n        // Regular paragraph\n        html += `<p>${trimmed.replace(/\\n/g, '<br/>')}</p>`;\n      }\n    });\n    \n    // Close any open list at the end\n    if (inList) {\n      html += listHtml + '</ul>';\n    }\n    \n    // Close the main content div\n    html += '</div>';\n    \n    return html;\n  }\n\n  /**\n   * Create a new epic in Jira\n   * @param {string} epicName - Name of the epic\n   * @param {string} epicSummary - Summary of the epic\n   * @param {string} epicDescription - Description of the epic\n   * @param {string} projectKey - Jira project key\n   * @returns {Promise<Object>} Created epic data\n   */\n  async createJiraEpic(epicName, epicSummary, epicDescription = '', projectKey = 'ROIA') {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/create-epic?project_key=${projectKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          epic_name: epicName,\n          epic_summary: epicSummary,\n          epic_description: epicDescription\n        })\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error creating Jira epic:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check Jira connection health\n   * @returns {Promise<Object>} Jira health status\n   */\n  async checkJiraHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/health`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error checking Jira health:', error);\n      return {\n        status: 'unhealthy',\n        service: 'jira',\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Get all epics from a project\n   * @param {string} projectKey - Jira project key\n   * @param {number} maxResults - Maximum number of results to return\n   * @returns {Promise<Array>} Array of Jira epics\n   */\n  async getJiraEpics(projectKey = 'ROIA', maxResults = 500) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/jira/epics?project_key=${projectKey}&max_results=${maxResults}`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`Error fetching Jira epics for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find epics that match the classified intent and user context\n   * @param {Object} classifiedIntent - The classified intent\n   * @param {Object} userInfo - Optional user information\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @param {number} maxResults - Maximum number of matching epics to return\n   * @returns {Promise<Array>} Array of matching epics with match scores\n   */\n  async matchJiraEpics(classifiedIntent, userInfo = null, projectKey = 'ROIA', maxResults = 3) {\n    try {\n      if (!classifiedIntent) {\n        throw new Error(\"Classified intent is required\");\n      }\n      \n      // Create a properly sanitized version of the intent to match the backend model\n      // This ensures we don't send extra or invalid fields that would cause validation errors\n      // Based on the backend ClassifiedIntent model, we need exact enum values\n      const sanitizedIntent = {\n        type: String(classifiedIntent.type || 'story').toLowerCase(),\n        summary: String(classifiedIntent.summary || ''),\n        description: String(classifiedIntent.description || 'No description provided'),\n        acceptance_criteria: Array.isArray(classifiedIntent.acceptance_criteria) \n          ? classifiedIntent.acceptance_criteria.map(ac => String(ac))\n          : [],\n        priority: String(classifiedIntent.priority || 'medium').toLowerCase(),\n        epic_keywords: Array.isArray(classifiedIntent.epic_keywords) \n          ? classifiedIntent.epic_keywords.map(kw => String(kw))\n          : [],\n        confidence: Math.max(0.0, Math.min(1.0, Number(classifiedIntent.confidence || 0.8)))\n      };\n      \n      // Validate enum values to match backend expectations\n      const validTypes = ['story', 'bug', 'task', 'epic', 'comment'];\n      const validPriorities = ['low', 'medium', 'high', 'critical'];\n      \n      if (!validTypes.includes(sanitizedIntent.type)) {\n        console.warn(`Invalid type '${sanitizedIntent.type}', defaulting to 'story'`);\n        sanitizedIntent.type = 'story';\n      }\n      \n      if (!validPriorities.includes(sanitizedIntent.priority)) {\n        console.warn(`Invalid priority '${sanitizedIntent.priority}', defaulting to 'medium'`);\n        sanitizedIntent.priority = 'medium';\n      }\n      \n      const requestBody = {\n        classified_intent: sanitizedIntent,\n        max_results: maxResults\n      };\n      \n      // Add user info if provided\n      if (userInfo) {\n        requestBody.user_info = {\n          username: String(userInfo.username || 'current_user'),\n          display_name: userInfo.display_name ? String(userInfo.display_name) : null,\n          email: userInfo.email ? String(userInfo.email) : null,\n          department: userInfo.department ? String(userInfo.department) : null\n        };\n      }\n      \n      console.log('Sanitized request body for match-epics:', JSON.stringify(requestBody, null, 2));\n      \n      // Use query parameter for project_key to match the updated backend API\n      const url = new URL(`${API_BASE_URL}/jira/match-epics`);\n      url.searchParams.append('project_key', projectKey);\n      \n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody)\n      });\n      \n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n          const errorData = await response.json();\n          throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        } else {\n          const errorText = await response.text();\n          throw new Error(errorText || `HTTP error! status: ${response.status}`);\n        }\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error(`Error matching Jira epics for project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create Jira issue and link it to the specified epic\n   * @param {Object} processedData - Processed transcript data\n   * @param {string} epicKey - The epic key to link the issue to\n   * @param {string} projectKey - Jira project key (defaults to ROIA)\n   * @returns {Promise<Object>} Created Jira issue data\n   */\n  async createJiraIssueWithEpic(processedData, epicKey, projectKey = 'ROIA') {\n    try {\n      if (!processedData || !epicKey) {\n        throw new Error(\"Processed data and epic key are required\");\n      }\n      \n      // Validate project key against allowed values\n      const allowedProjectKeys = ['ROIA', 'PROPS'];\n      if (!allowedProjectKeys.includes(projectKey)) {\n        throw new Error(`Invalid project key. Allowed values: ${allowedProjectKeys.join(', ')}`);\n      }\n      \n      const response = await fetch(`${API_BASE_URL}/jira/create-with-epic?project_key=${projectKey}&epic_key=${epicKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(processedData)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error(`Error creating Jira issue with epic link in project ${projectKey}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current user info from session or browser\n   * @returns {Object} User information that can be used for context-aware matching\n   */\n  getCurrentUserInfo() {\n    // In a real application, this would come from authentication\n    // For now, we'll use dummy data or try to extract from browser\n    const userInfo = {\n      username: sessionStorage.getItem('username') || 'current_user',\n      display_name: sessionStorage.getItem('display_name') || 'Current User',\n      email: sessionStorage.getItem('email') || null,\n      department: sessionStorage.getItem('department') || null\n    };\n    \n    return userInfo;\n  }\n\n  // Confluence API Methods\n  \n  /**\n   * Check the health of the Confluence connection\n   * @returns {Promise<Object>} Health status information\n   */\n  async checkConfluenceHealth() {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/health`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error checking Confluence health:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get pages from a Confluence space\n   * @param {string} spaceKey - The space key to retrieve pages from\n   * @param {number} maxResults - Maximum number of pages to return\n   * @returns {Promise<Array>} Array of Confluence pages\n   */\n  async getConfluencePages(spaceKey = 'ROIA', maxResults = 500) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/pages?space_key=${spaceKey}&max_results=${maxResults}`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching Confluence pages:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Find Confluence pages that match the classified intent\n   * @param {Object} classifiedIntent - The classified intent\n   * @param {Object} userInfo - Optional user information\n   * @param {string} spaceKey - Confluence space to search in\n   * @param {number} maxResults - Maximum number of matching pages to return\n   * @returns {Promise<Array>} Array of matching pages with match scores\n   */\n  async matchConfluencePages(classifiedIntent, userInfo = null, spaceKey = 'ROIA', maxResults = 3) {\n    try {\n      // Sanitize and format the classified intent similar to Jira integration\n      const sanitizedIntent = {\n        type: String(classifiedIntent.type || 'story').toLowerCase(),\n        summary: String(classifiedIntent.summary || ''),\n        description: String(classifiedIntent.description || 'No description provided'),\n        acceptance_criteria: Array.isArray(classifiedIntent.acceptance_criteria) \n          ? classifiedIntent.acceptance_criteria \n          : [],\n        priority: String(classifiedIntent.priority || 'medium').toLowerCase(),\n        epic_keywords: Array.isArray(classifiedIntent.epic_keywords) \n          ? classifiedIntent.epic_keywords \n          : [],\n        confidence: Number(classifiedIntent.confidence || 0.8)\n      };\n      \n      const requestBody = {\n        classified_intent: sanitizedIntent,\n        space_key: spaceKey,\n        max_results: maxResults\n      };\n      \n      // Add user info if provided\n      if (userInfo) {\n        requestBody.user_info = {\n          username: String(userInfo.username || 'current_user'),\n          display_name: userInfo.display_name ? String(userInfo.display_name) : null,\n          email: userInfo.email ? String(userInfo.email) : null,\n          department: userInfo.department ? String(userInfo.department) : null\n        };\n      }\n      \n      const response = await fetch(`${API_BASE_URL}/confluence/match-pages`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody)\n      });\n      \n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n          const errorData = await response.json();\n          throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        } else {\n          const errorText = await response.text();\n          throw new Error(errorText || `HTTP error! status: ${response.status}`);\n        }\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error matching Confluence pages:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Update a Confluence page with new content\n   * @param {string} pageId - The ID of the page to update\n   * @param {string} content - The content to add/update\n   * @param {string} comment - Version comment\n   * @param {boolean} append - Whether to append content or replace it\n   * @returns {Promise<Object>} Update response with page URL\n   */\n  async updateConfluencePage(pageId, content, comment = 'Updated via AI Project Management Suite', append = true) {\n    try {\n      const requestBody = {\n        page_id: pageId,\n        content: content,\n        comment: comment,\n        append: append\n      };\n      \n      const response = await fetch(`${API_BASE_URL}/confluence/update-page`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error updating Confluence page:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a specific Confluence page by ID\n   * @param {string} pageId - The ID of the page to retrieve\n   * @returns {Promise<Object>} Page data\n   */\n  async getConfluencePage(pageId) {\n    try {\n      const response = await fetch(`${API_BASE_URL}/confluence/page/${pageId}`);\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching Confluence page:', error);\n      throw error;\n    }\n  }\n}\n\nconst apiService = new ApiService();\nexport default apiService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}